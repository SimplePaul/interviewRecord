DFS算法
思想：一直往深处走，直到找到解或者走不下去为止
DFS(dep,...) // dep代表目前DFS的深度
{
	if (找到解或者走不下去了){
	   return;
	}
	枚举下种情况，DFS(dep + 1, ...)
}

DFS: 使用栈保存未被检测的节点，结点按照深度优先的次序被访问并依次压入栈中，并以相反的次序出栈进行新的检测
     类似于树的先根遍历，深搜的例子：走迷宫，没有办法用分身术来站在每一个走过的位置。
例子：
leetcode 394  

class Solution {
public:
     string DFS(string s, int &k){  // 在所有的层中是维护一个共同的索引值k
        string ans;  
        int cnt = 0; 
        while(k < s.size())  
        {  
            if(isdigit(s[k])){     // 判断是否是数字
                cnt = cnt * 10 + s[k++]-'0';    //  如果是遇到100这样的数字，那么则需要这样处理
            }  
            else if(s[k]=='['){  // 如果是左括号，则要进入下层递归
                string tem = DFS(s, ++k);      // 递归调用
                for(int i = 0; i < cnt; i++){
                     ans += tem; 
                } 
                cnt = 0;        // 
            }  
            else if(s[k]==']'){  
                k++;  
                return ans;  
            }  
            else ans += s[k++];  // 若是普通数字就直接加上
        }  
        return ans;  
    }  
      
    string decodeString(string s){
        string res;
        int k = 0;
        return DFS(s, k);
    }
};



leetcode 467 Unique Substring in Wraparounding string

思路：这道题说有一个无限长的封装字符串，然后又给了我们另一
个字符串p，问我们p有多少非空子字符串在封装字符串中。我们通过
观察题目中的例子可以发现，由于封装字符串是26个字符按顺序无限
循环组成的，那么满足题意的p的子字符串要么是单一的字符，要么是
按字母顺序的子字符串。这道题遍历p的所有子字符串会TLE，因为如
果p很大的话，子字符串很多，会有大量的满足题意的重复子字符串，
必须要用到trick，而所谓技巧就是一般来说你想不到的方法。我们看
abcd这个字符串，以d结尾的子字符串有abcd, bcd, cd, d，那么我们
可以发现bcd或者cd这些以d结尾的字符串的子字符串都包含在abcd中，
那么我们知道以某个字符结束的最大字符串包含其他以该字符结束的字符
串的所有子字符串，说起来很拗口，但是理解了我上面举的例子就行。
那么题目就可以转换为分别求出以每个字符(a-z)为结束字符的最长连续
字符串就行了，我们用一个数组cnt记录下来，最后再求出数组cnt的所有
数字之和就是我们要的结果啦

class Solution {
public:
    int findSubstringInWraproundString(string p) { // 很有技巧的一个题
         vector<int> cnt(26, 0);    // 对应26个字母，注意vector的初始化
        int len = 0;
        for (int i = 0; i < p.size(); ++i) {
            if (i > 0 && (p[i] == p[i - 1] + 1 || p[i - 1] - p[i] == 25)) {
                ++len;
            } 
            else {
                len = 1;   // 若是不再连续就将len置1重新开始
            }
            cnt[p[i] - 'a'] = max(cnt[p[i] - 'a'], len);  // 用len的值更新cnt的值
        }
        return accumulate(cnt.begin(), cnt.end(), 0);    // 将cnt的所有的值累加起来
    }
};


leetcode 647. Palindromic Substrings 回文字串

题目：
Given a string, your task is to count how many palindromic substrings in this string.

The substrings with different start indexes or end indexes are counted as different substrings even they consist
 of same characters.

Example 1:
Input: "abc"
Output: 3
Explanation: Three palindromic strings: "a", "b", "c".
Example 2:
Input: "aaa"
Output: 6
Explanation: Six palindromic strings: "a", "a", "a", "aa", "aa", "aaa".

思路一：dp思想
参考链接：http://blog.csdn.net/lishichengyan/article/details/77103324
定义d[i][j]：若从i到j的字符串为回文，则为真（1），否则为假（0），那么d[i][j]为真的前提是：头尾两个字符串相同并且去掉头尾以后的字串也是
回文（即d[i+1][j-1]为真），这里面要注意特殊情况，即：去掉头尾以后为空串，所以如果j-i<3，并且头尾相等，也是回文的。

class Solution {
public:
    int countSubstrings(string s) {
        int n = s.size(), count = 0;
        vector<vector<int>> dp(n, vector<int> (n));   //二维vector初始化，打表
        for ( int end = 0; end < n; ++end ) {
            dp[end][end] = 1;                         // 每一个字符都是一个回文
            ++count;                         
            for ( int start = 0; start < end; ++start ) {
                if ( s[start] == s[end] && (start+1 >= end-1 || dp[start+1][end-1])) {
                    dp[start][end] = 1;
                    ++count;         // 有一个为真那么结果值就加一
                }
            }
        }
        return count;
    }
};

思路二： 使用从 中心向外扩展的方法，注意回文的字符串个数为奇数或者偶数的时候